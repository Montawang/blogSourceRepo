---
title: 猴排！？一道高考题！？出题人的无下限猴子专场!
mathjax: true
copyright: true
comment: true
date: 2018-10-03 14:40:16
tags:
  - NOIP 模拟
categories: NOIP
photo: /2018/10/03/猴排！？一道高考题！？出题人的无下限猴子专场/photo1.png
---

{% note default %}

今天模拟测的第一道题实在是妙，本以为是简单排序，但是发现某些数据下过不了，后来想打暴力，但是怕直接被 T 掉，于是使用了全世界最好的[猴子排序](https://zh.wikipedia.org/wiki/Bogo%E6%8E%92%E5%BA%8F)，骗了个 35 分。。。。。。

{% endnote %}

<!-- more -->

### 题目描述

Coder Jun 当年没有经历高考就直接保送进了名牌大学，如今孩子都上初中了，想想保送政策已经取消，孩子过几年铁定要参加高考，心里非常着急，于是决定抽空做些高考题，好给孩子传授传授经验。于是他遇到了这样一道高考题。题目给你了 $N$ 个二元组，其中第i个二元组表示为 $(A_i,B_i)$。使用这个二元组，我们可以构造出另一个序列 $T$，构造方法如下：

1. 当 $i=1$ 时，$T_i=A_i+B_i$
2. 当 $i\neq 1$ 时，$T_i=B_i+\max\lbrace T_{i-1},\sum_{j=1}^i A_j\rbrace$

由于计算T时需要用到 `max` 函数令 Coder Jun 感到非常不爽，所以 Coder Jun 想让你帮他来最小化 $T_N$ 的值，即你需要对这 $N$ 个二元组进行重排，使得 $T_N$ 的值最小。

### 题解

#### 骗分算法

嗯，反正题目中说的就是重排，而我又不知道怎么排，那当然就是猴排了...... 35分骗分代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define maxn 100010
typedef long long int64;
struct Tuple { int A; int B; };
int N;
Tuple tuple[maxn];
// 这个 tuple 在某些地方好像会编译出错......
map<string, int64> mp;
int64 ans = (1 << 30), prefix[maxn];
string sit;

inline void prepare() {
  prefix[1] = tuple[1].A; 
  for (int i = 2; i <= N; ++i) prefix[i] = prefix[i - 1] + tuple[i].A;
}

inline int64 calc() {
  int64 T_i_1, T_i;
  for (int i = 1; i <= N; ++i) {
    if (i == 1) {
      T_i = tuple[i].A + tuple[i].B; T_i_1 = T_i;
    } else {
      T_i = tuple[i].B + max(T_i_1, prefix[i]); T_i_1 = T_i;
    }
  }
  return T_i;
}

inline string hash() {
  ostringstream ret;
  for (int i = 1; i <= N; ++i) ret << tuple[i].A << " " << tuple[i].B << endl;
  return ret.str();
}

int main() {
  ifstream in("gaokao.in");
  ofstream out("gaokao.out");
  srand((unsigned)time(NULL));
  in >> N;
  for (int i = 1; i <= N; ++i) { in >> tuple[i].A >> tuple[i].B; }
  for (int i = 1; i <= 10000000; ++i) {
    if (clock() >= 600) break;
    prepare(); mp[hash()] = calc();
    if (clock() >= 600) break;
    random_shuffle(tuple + 1, tuple + N + 1);
    if (clock() >= 600) break;
    // 骗分精髓之处，极限卡时
  }
  map<string, int64>::iterator iter;
  for (iter = mp.begin(); iter != mp.end(); ++iter)
    if (ans > iter->second) { ans = iter->second; sit = iter->first; }
  out << ans << endl << sit;
  return 0;
}
```
这个代码看看开心一下就好，虽然说对于某些数据是可能对的，但是还是要看人品。

#### 正解

先双手送上[洛谷上的原题](https://www.luogu.org/problemnew/show/P2123)👍。
首先，我们来了解一下[偏序关系](https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB)这个东西，我们其实只要明白严格偏序和非严格偏序的性质就行了（主要是传递性这个东西）。然后我们定义一个函数 $\operatorname{sgn}(x)$ 表示 $x$ 的符号。然后我们就可以开始求解这道题了。这道题无非就是找出一个排序方法来令所有的情况下的结果最小或最大。因为我们有公式：

$$
T_i=
\begin{cases}
A_i+B_i & \text{when $i=1$} \\
B_i+\max\lbrace T_{i-1},sum_{j=1}^i A_j\rbrace & \text{when $i\neq1$}
\end{cases}
$$

所以 $T_i$ 是严格递增的。然后我们用相邻交换法来考虑偏序关系（排序的方法）。




---

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-7465666912424994"
     data-ad-slot="3198608984"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<br/>
