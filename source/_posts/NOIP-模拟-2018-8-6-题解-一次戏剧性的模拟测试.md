---
title: '[NOIP 模拟] 2018-8-6 题解: 一次戏剧性的模拟测试'
date: 2018-08-06 17:05:38
tags:
	- NOIP 模拟
	- 题解
	- 神题
categories: NOIP
mathjax: true
copyright: true
---

今天模拟测试一共有三道题，这里先发一下有关这三道题的题解，有关这几类题目的详解会在以后更新。
<!-- more -->
### T1 奇数码问题

**[题目描述]**

你一定玩过八数码游戏，它实际上是在一个$3\times 3$的网格中进行的，$1$个空格和$1 \sim 8$这$8$个数字恰好不重不漏地分布在这$3 \times 3$的网格中。

例如：

	5 2 8
	1 3 _
	4 6 7

在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。
例如在上例中，空格可与左、上、下面的数字交换，分别变成：

	5 2 8       5 2 _      5 2 8
	1 _ 3       1 3 8      1 3 7
	4 6 7       4 6 7      4 6 _

奇数码游戏是它的一个扩展，在一个$n \times n$的网格中进行，其中n为奇数，1个空格和$1 \sim n\times n-1$这$n\times n-1$个数恰好不重不漏地分布在$n\times n$的网格中。

空格移动的规则与八数码游戏相同，实际上，八数码就是一个$n=3$的奇数码游戏。

现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。

**[输入格式]**

	多组数据，对于每组数据：
	第1行一个奇整数n。
	接下来n行每行n个整数，表示第一个局面。
	接下来n行每行n个整数，表示第二个局面。
	局面中每个整数都是0~n*n-1之一，其中用0代表空格，其余数值与奇数码游戏中的意
	义相同，保证这些整数的分布不重不漏。

**[输出格式]**

	对于每组数据，若两个局面可达，输出TAK，否则输出NIE。

**[样例输入]**

	3
	1 2 3
	0 4 6
	7 5 8
	1 2 3
	4 5 6
	7 8 0
	1
	0
	0

**[样例输出]**

	TAK
	TAK

**[数据范围与约定]**

	对于30%的数据，1<=n<=3；
	对于60%的数据，1<=n<=50；
	对于100%的数据，1<=n<=500，n为奇数，每个测试点不超过10组。

**[题解]**

通过题目可知，这是一道经典的八数码问题，可以说是模板题。
对于这种问题，可以把方阵转为链（忽略输入的$0$），然后统计初始状态和目标状态的逆序对的数量。
若逆序对数的奇偶性相同，则可以到达，否则不行。

**[参考代码]**

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a, t[300010];

inline void modify(int x) {
	for (int i = x; i <= n; i += i & -i) ++t[i];
}

inline int query(int x) {
	int res = 0;
	for (int i = x; i; i -= i & -i)
		res += t[i];
	return res;
}

inline int work() {
	memset(t, 0, sizeof(t));
	int cnt = 0;
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &a);
		if (!a) continue;
		cnt += query(n) - query(a);
		modify(a);
	}
	return cnt & 1;
}

int main() {
	freopen("digital.in", "r", stdin);
	freopen("digital.out", "w", stdout);

	for (; scanf("%d", &n) == 1; ) {
		n *= n;
		if (work() == work()) printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}

// 此处使用了树状数组做
// 本题还可以使用归并排序做，有兴趣的同学可以试试看用归并排序做。

```

**[评价]**

第一题嘛......水题，模板题，送分题......

### T2 树洞
**[题目描述]**

在一片栖息地上有$N$棵树，每棵树下住着一只兔子，有$M$条路径连接这些树。更特殊地是，只有一棵树有$3$条或更多的路径与它相连，其它的树只有$1$条或$2$条路径与其相连。换句话讲，这些树和树之间的路径构成一张$N$个点、$M$条边的无向连通图，而度数大于$2$的点至多有$1$个。

近年以来，栖息地频繁收到人类的侵扰。兔子们联合起来召开了一场会议，决定在其中$K$棵树上建造树洞。当危险来临时，每只兔子均会同时前往距离它最近的树洞躲避，路程中花费的时间在数值上等于距离。为了在最短的时间内让所有兔子脱离危险，请你安排一种建造树洞的方式，使最后一只到达树洞的兔子所花费的时间尽量少。

**[输入格式]**

	第一行有3个整数N，M，K，分别表示树（兔子）的个数、路径数、计划建造的树洞数。
	接下来M行每行三个整数x,y，表示第x棵树和第y棵树之间有一条路径相连。
	1<=x,y<=N，x≠y，任意两棵树之间至多只有1条路径。

**[输出格式]**

	一个整数，表示在最优方案下，最后一只到达树洞的兔子所花费的时间。

**[样例输入]**

	5 5 2
	1 2
	2 3
	3 1
	1 4
	4 5

**[样例输出]**

	1

**[数据范围与约定]**

	对于20%的数据，1 ≤  n ≤ 10。
	对于另外30%的数据，每棵树至多与2条路径相连。
	对于另外30%的数据，保证存在一种最优解，使与3条或更多路径相连的树上一定建造了树洞。
	对于100%的数据，1 ≤ n ≤ 2000，n-1<=m<=n*(n-1)/2。

**[题解]**

求最大值最小，而且答案满足单调，很显然可以用二分 
如何验证？
首先考虑一条链的情况，答案必然是$\frac{n - k}{k}$；

而另外存在一个特殊点有三条及以上的边的情况
我们先枚举一个点，可以将特殊点覆盖，覆盖后，
原来的图将断成若干条链，然后重复之前链的做法统计答案是否超过k，
来判断二分的答案是否正确

**[参考代码]**

```cpp
#include<cstdio>
#include<cstring>

int n, m, k, rt, deep, mi;
int deg[2005], dis[2005];
bool vis[2005], first[2005];
int head[2005], num;

struct edge {
	int nxt, to;
} e[4000005];

void add(int x, int y) {
	e[++num].nxt = head[x];
	e[num].to = y;
	head[x] = num;
}

void dfs(int x, int len) {
	deep += 1;
	vis[x] = 1;
	if (!len) return;
	for (int i = head[x]; i; i = e[i].nxt) {
		int v = e[i].to;
		if (!vis[v]) {
			dis[v] = dis[x] + 1;
			dfs(v, len - 1);
		}
	}
}

bool check(int x) {
	memset(vis, 0, sizeof(vis));
	dfs(rt, x);
	memcpy(first, vis, sizeof(vis));
	for (int i = 1; i <= n; i++) {
		if (first[i]) {
			int res = 0;
			memset(vis, 0, sizeof(vis));
			dfs(i, x);
			for (int j = 1; j <= n && res < k; j++)
			if (!vis[j]) {
				deep = 0;
				dfs(j, n);
				res += (deep + 2 * x) / (2 * x + 1);
			}
			if (res < k) return 1;
		}
	}
	return 0;
}

int main() {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= m; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		deg[x]++;
		deg[y]++;
		add(x, y);
		add(y, x);
	}
	for (int i = 1; i <= n; i++) {
		if (deg[i] > 2) {
			rt=i;
			break;
		}		
	}
	if (!rt) {
		printf("%d", (n + k - 1) / k / 2);
		return 0;
	}
	int l = 1, r = n - 1, ans = n;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (check(mid)) {
			ans = mid;
			r = mid - 1;
		}
		else l = mid + 1;
	}
	printf("%d", ans);
}


```

**[评价]**

之所以标题称这次模拟为“戏剧性的模拟测试”，是因为这道题一开始不会，用了个随机数骗了个 10 分（逃）。

虽然这种骗分方法不值得提倡，但也是没有办法的办法，毕竟信奥有时就是这么玄。

对于这种二分答案的题要记住题目所满足的条件：单调性，一般遇到最大值求最小，最小值求最大的这种坑题可以考虑二分答案的方法了。


### T3 まんふは函数

**[吐槽]**

为什么这道题一上来就吐槽呢？首先，这道题的思维难度比较大，其次，这道题的思维难度比较小（WTF!!??）。
<div style="align: center"> <img src="黑人问号.jpg"/> </div>
首先来看一下题目中日语的发音：
<div style="align: center"> <img src="翻译1.jpg"/> </div>
重新排列之后：
<div style="align: center"> <img src="翻译2.jpg"/> </div>
经过 Google 的提醒：
<div style="align: center"> <img src="翻译3.jpg"/> </div>

这不就是 Huffman 的意思吗......
明摆着让我们用霍夫曼树......

（当然，从题中所给的公式也可以看出来，比如考试的时候我就看出来了（逃）。）

**[题目描述]**

有n个正整数 $A[1], A[2]...A[n]$，满足 ${A[i]}\geqslant{A[i+1]}$。
它们可以产生$n$个正整数 $B[1], B[2]...B[n]$，其中 $B[i]=\sum_{j=i}^n A[j]$

まんふは函数（マンフハ函数）$f:(Z,Z) \rightarrow Z$定义为：

$$
f(i,j)=
\begin{cases}
0, & \text{($i$,$j$) = (1,1)}\\
\min\lbrace f(i-1,j+1), f(i,\lceil\frac{j}{2}\rceil)+B[i]\rbrace, & i,j \in [1,n], \text{ } i,j \neq{(1,1)}\\
10^{11037}, & \text{otherwise}
\end{cases}
$$

试求$f(n,1)$。

**[输入格式]**

	输入包含多组数据，不超过10组。
	每组数据的第一行是一个正整数，第二行n个正整数A[i]。

**[输出格式]**

	对于每组数据，输出一个整数表示f(n,1)。

**[样例输入]**

	3
	1 1 1
	5
	28 26 25 24 1
	10
	996 901 413 331 259 241 226 209 139 49

**[样例输出]**

	5
	233
	11037

**[样例解释]**

	对于第一组数据：
	f(1, 1) = 0
	f(1, 2) = f(1, 1) + 3 = 3
	f(1, 3) = f(1, 2) + 3 = 6
	f(2, 1) = min(f(2, 1) + 2, f(1, 2)) = 3
	f(2, 2) = min(f(2, 1) + 2, f(1, 3)) = 5
	f(2, 3) = f(2, 2) + 2 = 7
	f(3, 1) = min(f(3, 1) + 1, f(2, 2)) = 5
**[数据范围与约定]**

	对于30%的数据，满足1 ≤ n ≤ 20。
	对于60% 的数据，满足1 ≤ n ≤ 1000。
	对于 100% 的数据，满足1 ≤ n ≤ 100000，1 ≤ A[i] ≤ 10000。

**[题解]**

对于会日语的同学，直接看吐槽就行了，如果不会日语呢？
先仔细读题，研究题中所给的表达式，有两个边界条件，这是不是很像状态转移方程？
那么我们就可以从动态规划的角度来解决题目的意思。$B$ 数组其实是 $A$ 的一个后缀和，
而 $min$ 中的两个 $f(i,j)$, 一个减一，一个除以二，自然而然地联想到这是树的合并，
记 $f(i,j)$ 为合并了 $i$ 个点，产生 $j$ 棵树的状态，
那么我们要么合并到树中，要么合并两棵子树，为了使合并的总量最小，
我们就可以用霍夫曼树来解了，题目的思路就开朗了。

**[参考代码]**

```cpp
#include <bits/stdc++.h>
using namespace std;

#define maxn 110000
#define int64 long long

int64 node[maxn], u[maxn];
int64 tot, n, len, ans;
int64 x, y;

int64 top() {
	if (x <= n && (y > len || node[x] < u[y]))
		return node[x++];
	else return u[y++];
}

int main() {
	while (~scanf("%d",&n)) {
		ans = 0;
		len = 0;
		x = 1;
		y = 1;
		tot = 0;
		memset(node, 0, sizeof(node));
		memset(u, 0, sizeof(u));
		tot = n;
		for (int i = 1; i <= n; ++i) {
			int tmp;
			scanf("%d",&tmp);
			node[tot--] = tmp;
		}
		for (int i = 1; i < n; ++i) {
			u[len + 1] = top() + top();
			ans += u[++len];
		}
		printf("%lld\n",ans);
	}
	return 0;
}

// 提醒注意多组数据读入问题
// ++i 和 i++ 的区别要清楚

```

**[评价]**

好题，由类状态转移方程推出题目的原意，再进行解答，思维难度比较大，好题。


### 总结

今天三道题，除了第三道题，另外两道题都不是很考验思维，只要还是技巧。
看来我还是需要提升自己的知识水平，防止再出现第二题做不出，只能随机数的情况。

---